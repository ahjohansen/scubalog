/***************************************************************************
                          udcfexporter.cpp  -  description
                             -------------------
    begin                : Tue Sep 11 2001
    copyright            : (C) 2001 by Jordi Cantón
    email                : 
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
//*****************************************************************************
/*!
  \file udcfexporter.cpp
  \brief This file contains the implementation of the UDCFExporter Class.

  This file is part of ScubaLog, a dive logging application for KDE.
  ScubaLog is free software licensed under the GPL.

  \par Copyright:
  Jordi Cantón
*/
//*****************************************************************************


#include <qdom.h>
#include <qfile.h>
#include <qtextstream.h>
#include <qmessagebox.h>
#include <qregexp.h>
#include <kapplication.h>
#include <klocale.h>
#include <qmessagebox.h>
#include "logbook.h"
#include "udcfexporter.h"
#include "locationlog.h"
#include "equipmentlog.h"
#include "divelist.h"


UDCFExporter::UDCFExporter(){
}

UDCFExporter::~UDCFExporter(){
}

//*****************************************************************************
/*!
  Export the logbook \a cLogBook to the file \a cFileName.
  Returns `true' on success, `false' on failure.
*/
//*****************************************************************************
bool
UDCFExporter::exportLog(const DiveLog& /*cLog*/,
                        const QString& /*cFileName*/) const
{

return false; // not implemented, then false
}// end of method

//*****************************************************************************
/*!
  Export the logbook \a cLogBook to the file \a cFileName.
  Returns `true' on success, `false' on failure.
  \warning NOT INPLEMENTED YET
*/
//*****************************************************************************

bool
UDCFExporter::exportLogBook(const LogBook& cLogBook,
              const QString& cFileName) const
 {
 QDomDocument doc( "mydocument" );
 doc.setContent(QString("<PROFILE UDCF=\"1\"></PROFILE>") );
 // the header of the document
 buildHead(doc);
 //exptra pram info inside a <PROGRAM> tag
 QDomElement extraprogram=doc.createElement( "PROGRAM" );
 //personal info
 buildPersInfo(doc,extraprogram,cLogBook);
 //location logs
 buildLocationLogs(doc,extraprogram,cLogBook);
 //equipment Log
 buildEquipmentLogs(doc,extraprogram,cLogBook);
 //add the program tag to the document
 doc.documentElement().appendChild(extraprogram);
 // dive logs
 buildDiveLogs(doc,cLogBook);
 QFile cFile(cFileName);
 bool isOpen = cFile.open(QIODevice::WriteOnly);
 if ( false == isOpen ) {
      QString cMessage;
      cMessage = QString(i18n("Couldn't open file for output"))
        + "\n(`" + cFileName + "')";
      errorMessage(cMessage);
      return false;
    }
  //output to file
  QTextStream cStream(&cFile);
  cStream << doc.toString();

  // Ensure output was successful
  if ( cFile.error() != QFile::NoError ) {
      QString cMessage;
      cMessage = QString(i18n("Error outputting log"))
        + "\n(`" + cFileName + "')";
      errorMessage(cMessage);
      cFile.remove();
      return false;
      }
  // close file
  cFile.close();

 return true;
 }//end of method


//*****************************************************************************
/*!
  Display the error-message \a cMessage.
*/
//*****************************************************************************

void
UDCFExporter::errorMessage(const QString& cMessage) const
{
  QMessageBox::warning(QApplication::topLevelWidgets().at(0),
                       i18n("[ScubaLog] Output error"),
                       cMessage);
}


//*****************************************************************************
/*!
  Builds the head of the document
*/
//*****************************************************************************

void
UDCFExporter::buildHead(QDomDocument& doc) const
{

 QDomElement docElem = doc.documentElement();
 QDomComment coment = doc.createComment( "This file was generated by ScubaLog 0.3" );
 docElem.appendChild( coment );
 QDomElement elem = doc.createElement( "UNITS" );
 QDomText textnode = doc.createTextNode ( "Metric" );
 elem.appendChild( textnode );
 docElem.appendChild( elem );
 elem = doc.createElement( "DEVICE" );
 QDomElement elem2 = doc.createElement( "VENDOR" );
 textnode = doc.createTextNode ( "GNU" );
 elem2.appendChild( textnode );
 elem.appendChild( elem2 );
 elem2 = doc.createElement( "MODEL" );
 textnode = doc.createTextNode ( "ScubaLog" );
 elem2.appendChild( textnode );
 elem.appendChild( elem2 );
 elem2 = doc.createElement( "VERSION" );
 textnode = doc.createTextNode ( "0.3" );
 elem2.appendChild( textnode );
 elem.appendChild( elem2 );
 docElem.appendChild( elem );
}
//*****************************************************************************
/*!
  Builds personal info
*/
//*****************************************************************************

void
UDCFExporter::buildPersInfo(QDomDocument& doc,QDomElement &docElem,const LogBook& cLogBook) const
{

 QDomComment coment = doc.createComment( "Personal info" );
 docElem.appendChild( coment );
 QDomElement elem = doc.createElement( "PERSONAL" );
 QDomElement elem2 = doc.createElement( "NAME" );
 QDomText textnode = doc.createTextNode ( cLogBook.diverName() );
 elem2.appendChild( textnode );
 elem.appendChild( elem2 );
 docElem.appendChild( elem );
 elem2 = doc.createElement( "MAIL" );
 textnode = doc.createTextNode ( cLogBook.emailAddress() );
 elem2.appendChild( textnode );
 elem.appendChild( elem2 );
 docElem.appendChild( elem );
 elem2 = doc.createElement( "URL" );
 textnode = doc.createTextNode ( cLogBook.wwwUrl() );
 elem2.appendChild( textnode );
 elem.appendChild( elem2 );
 docElem.appendChild( elem );
 elem2 = doc.createElement( "COMMENTS" );
 textnode = doc.createTextNode ( cLogBook.comments() );
 elem2.appendChild( textnode );
 elem.appendChild( elem2 );
 docElem.appendChild( elem );

}
//*****************************************************************************
/*!
  Builds location logs
*/
//*****************************************************************************

void
UDCFExporter::buildLocationLogs(QDomDocument& doc,QDomElement& docElem,const LogBook& cLogBook) const
{

 QDomComment coment = doc.createComment( "Location Logs" );
 docElem.appendChild( coment );
 QDomElement elem = doc.createElement( "LOCATIONS" );
 QDomElement location,auxelem;
 QDomText textnode;
 // Write all the location logs
 const QList<LocationLog*>& locationList = cLogBook.locationList();
 QListIterator<LocationLog*> i(locationList);
 while ( i.hasNext() ) {
   const LocationLog* pcLocationLog = i.next();
      location= doc.createElement( "LOCATION" );
      auxelem = doc.createElement( "NAME" );
      textnode = doc.createTextNode ( pcLocationLog->getName() );
      auxelem.appendChild(textnode);
      location.appendChild(auxelem);
      auxelem = doc.createElement( "DESCRIPTION" );
      textnode = doc.createTextNode ( pcLocationLog->getDescription() );
      auxelem.appendChild(textnode);
      location.appendChild(auxelem);
      elem.appendChild(location);
    }

 docElem.appendChild( elem );

}

//*****************************************************************************
/*!
  Create teh part of the tree for equipment logs. The tags used are not part of
  UDFC format.
*/
//*****************************************************************************

void
UDCFExporter::buildEquipmentLogs(QDomDocument& doc,QDomElement& docElem,const LogBook& cLogBook) const
{

 QDomComment coment = doc.createComment( "Equipment Logs" );
 docElem.appendChild( coment );
 QDomElement elem = doc.createElement( "EQUIPMENT" );
 QDomElement piece,auxelem,date,dateelem;
 QDomText textnode;
 // Write all the equipment logs, one for each piece of equipment
 QList<EquipmentLog*>& equipmentLog = cLogBook.equipmentLog();
 QListIterator<EquipmentLog*> iE(equipmentLog);
 while ( iE.hasNext() ) {
   const EquipmentLog* pcEquipmentLog = iE.next();
      piece= doc.createElement( "PIECE" );
      auxelem = doc.createElement( "TYPE" );
      textnode = doc.createTextNode ( pcEquipmentLog->type() );
      auxelem.appendChild(textnode);
      piece.appendChild(auxelem);
      auxelem = doc.createElement( "NAME" );
      textnode = doc.createTextNode ( pcEquipmentLog->name() );
      auxelem.appendChild(textnode);
      piece.appendChild(auxelem);
      auxelem = doc.createElement( "SERIAL" );
      textnode = doc.createTextNode ( pcEquipmentLog->serialNumber() );
      auxelem.appendChild(textnode);
      piece.appendChild(auxelem);
      auxelem = doc.createElement( "REQUIRE" );
      textnode = doc.createTextNode ( pcEquipmentLog->serviceRequirements() );
      auxelem.appendChild(textnode);
      piece.appendChild(auxelem);

      const QList<EquipmentHistoryEntry*>& history = pcEquipmentLog->history();
      QListIterator<EquipmentHistoryEntry*> iH(history);
      while ( iH.hasNext() ) {
        const EquipmentHistoryEntry* pcEquipmentHistoryEntry = iH.next();
          auxelem = doc.createElement( "SERVICE" );
          date= doc.createElement( "DATE" );
          dateelem= doc.createElement( "YEAR" );
          textnode = doc.createTextNode ( QString::number(pcEquipmentHistoryEntry->date().year()) );
          dateelem.appendChild(textnode);
          date.appendChild(dateelem);
          dateelem= doc.createElement( "MONTH" );
          textnode = doc.createTextNode ( QString::number(pcEquipmentHistoryEntry->date().month()) );
          dateelem.appendChild(textnode);
          date.appendChild(dateelem);
          dateelem= doc.createElement( "DAY" );
          textnode = doc.createTextNode ( QString::number(pcEquipmentHistoryEntry->date().day()) );
          dateelem.appendChild(textnode);
          date.appendChild(dateelem);
          auxelem.appendChild(date);
          date= doc.createElement( "COMMENT" );
          textnode = doc.createTextNode ( pcEquipmentHistoryEntry->comment() );
          date.appendChild(textnode);
          auxelem.appendChild(date);
          piece.appendChild(auxelem);
          }
      elem.appendChild(piece);
    }

 docElem.appendChild( elem );

}

//*****************************************************************************
/*!
  Create the part of the tree for Dive logs.
  \todo sets extra info for obligatory fields in the UDCF standard, lixe mix
   composition, etc
*/
//*****************************************************************************

void
UDCFExporter::buildDiveLogs(QDomDocument& doc,const LogBook& cLogBook) const
{
 QDomElement docElem = doc.documentElement();
 QDomComment coment = doc.createComment( "Dive Logs" );
 docElem.appendChild( coment );
 QDomElement repgroup,dive,auxelem,auxelem2,auxelem3;
 QDomText textnode;
 double bottomtime,divetime;
 // Write all the dive entries
 const DiveList& diveList = cLogBook.diveList();
 QListIterator<DiveLog*> iD(diveList);
 while ( iD.hasNext() ) {
   DiveLog* pcdiveLog = iD.next();
      repgroup= doc.createElement( "REPGROUP" );
      dive = doc.createElement( "DIVE" );
      auxelem = doc.createElement( "PLACE" );
      textnode = doc.createTextNode ( pcdiveLog->diveLocation() );
      auxelem.appendChild(textnode);
      dive.appendChild(auxelem);
      // date
      auxelem = doc.createElement( "DATE" );
      auxelem2= doc.createElement( "YEAR" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->diveDate().year()) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2= doc.createElement( "MONTH" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->diveDate().month()) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2= doc.createElement( "DAY" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->diveDate().day()) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      dive.appendChild(auxelem);
      //time
      auxelem = doc.createElement( "TIME" );
      auxelem2= doc.createElement( "HOUR" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->diveStart().hour()) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2= doc.createElement( "MINUTE" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->diveStart().minute()) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      dive.appendChild(auxelem);
      //surface interval, supposed to be infinity
      auxelem = doc.createElement( "SURFACEINTERVAL" );
      textnode = doc.createTextNode ( "infinity" );
      auxelem.appendChild(textnode);
      dive.appendChild(auxelem);
      //water temperature
      auxelem = doc.createElement( "TEMPERATURE" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->waterTemperature()) );
      auxelem.appendChild(textnode);
      dive.appendChild(auxelem);
      //density supposed to be always in sea
      auxelem = doc.createElement( "DENSITY" );
      textnode = doc.createTextNode ( "1030" );
      auxelem.appendChild(textnode);
      dive.appendChild(auxelem);
      //altitude, supposed sea level
      auxelem = doc.createElement( "ALTITUDE" );
      textnode = doc.createTextNode ( "0" );
      auxelem.appendChild(textnode);
      dive.appendChild(auxelem);
      //gases , only name provided, composition set always to air
      auxelem = doc.createElement( "GASES" );
      auxelem2 = doc.createElement( "MIX" );
      auxelem3 = doc.createElement( "MIXNAME" );
      textnode = doc.createTextNode ( pcdiveLog->gasType() );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "O2" );
      textnode = doc.createTextNode ( "0.21" );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "N2" );
      textnode = doc.createTextNode ( "0.79" );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "HE" );
      textnode = doc.createTextNode ( "0" );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem.appendChild(auxelem2);
      dive.appendChild(auxelem);
      //program section, all the extra info for the dive here
      auxelem = doc.createElement( "PROGRAM" );
      auxelem2 = doc.createElement( "SCUBALOG" );
      auxelem3 = doc.createElement( "NUMBER" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->logNumber()) );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "DIVETIME" );
      divetime=(pcdiveLog->diveTime().hour()*60)+pcdiveLog->diveTime().minute();
      textnode = doc.createTextNode ( QString::number(divetime) );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "BOTTOMTIME" );
      bottomtime=(pcdiveLog->bottomTime().hour()*60)+pcdiveLog->bottomTime().minute();
      textnode = doc.createTextNode ( QString::number(bottomtime) );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "AIRTEMP" );
      textnode = doc.createTextNode ( QString::number(pcdiveLog->airTemperature()) );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "PLANTYPE" );
      textnode = doc.createTextNode (QString::number(((int)pcdiveLog->planType())) );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "BUDDY" );
      textnode = doc.createTextNode (pcdiveLog->buddyName() );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "TYPE" );
      textnode = doc.createTextNode (pcdiveLog->diveType() );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem3 = doc.createElement( "DESCRIPTION" );
      textnode = doc.createTextNode (pcdiveLog->diveDescription() );
      auxelem3.appendChild(textnode);
      auxelem2.appendChild(auxelem3);
      auxelem.appendChild(auxelem2);
      dive.appendChild(auxelem);
      //samples section, define an square profile for the dive
      // start at 0 directly to bottom depth
      // botton time at bottom depth
      // go up to 3m and keep there divetime-bottomtime
      // go to surface
      auxelem = doc.createElement( "TIMEDEPTHMODE" );
      dive.appendChild(auxelem);
      auxelem = doc.createElement( "SAMPLES" );
      auxelem2 = doc.createElement( "SWITCH" );
      textnode = doc.createTextNode ( pcdiveLog->gasType() );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      // first point 0,0
      auxelem2 = doc.createElement( "T" );
      textnode = doc.createTextNode ( "0" );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2 = doc.createElement( "D" );
      textnode = doc.createTextNode ( "0" );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      //second point 0,bottomdepth
      auxelem2 = doc.createElement( "T" );
      textnode = doc.createTextNode ( "0" );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2 = doc.createElement( "D" );
      textnode = doc.createTextNode (QString::number( pcdiveLog->maxDepth()) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      //third point bottomtime,bottomdepth
      auxelem2 = doc.createElement( "T" );
      textnode = doc.createTextNode ( QString::number(bottomtime ) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2 = doc.createElement( "D" );
      textnode = doc.createTextNode (QString::number( pcdiveLog->maxDepth()) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      //fourth point bottontime,3 m
      auxelem2 = doc.createElement( "T" );
      textnode = doc.createTextNode ( QString::number(bottomtime ) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2 = doc.createElement( "D" );
      textnode = doc.createTextNode ( "3" );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      //fith point divetime,3m
      auxelem2 = doc.createElement( "T" );
      textnode = doc.createTextNode ( QString::number(divetime ) );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2 = doc.createElement( "D" );
      textnode = doc.createTextNode ( "3" );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      //last point ..,surface
      auxelem2 = doc.createElement( "T" );
      textnode = doc.createTextNode ( " " );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      auxelem2 = doc.createElement( "D" );
      textnode = doc.createTextNode ( "0" );
      auxelem2.appendChild(textnode);
      auxelem.appendChild(auxelem2);
      dive.appendChild(auxelem);
      repgroup.appendChild(dive);
      docElem.appendChild(repgroup);
    }
}


// Local Variables:
// mode: c++
// tab-width: 8
// c-basic-offset: 2
// indent-tabs-mode: nil
// coding: utf-8
// End:
